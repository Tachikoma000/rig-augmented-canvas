/**
 * Canvas utilities module provides functions for interacting with Obsidian's Canvas.
 * It includes interfaces for Canvas data structures and functions for manipulating nodes.
 */

import { App, TFile, TAbstractFile } from "obsidian";

/**
 * Represents a node in an Obsidian Canvas.
 * Includes position, size, content, and metadata for AI-generated content.
 */
export interface CanvasNode {
    id: string;                  // Unique identifier for the node
    x: number;                   // X position on the canvas
    y: number;                   // Y position on the canvas
    width: number;               // Width of the node
    height: number;              // Height of the node
    type: string;                // Type of node (text, file, etc.)
    text?: string;               // Text content for text nodes
    file?: string;               // File path for file nodes
    subpath?: string;            // Subpath within a file (e.g., heading)
    url?: string;                // URL for link nodes
    // Metadata for AI-generated content
    metadata?: {
        isAIGenerated?: boolean;                         // Whether this node was generated by AI
        generationType?: 'response' | 'question' | 'prompt'; // Type of AI-generated content
        timestamp?: number;                              // When the node was generated
    };
}

/**
 * Represents an edge (connection) between nodes in an Obsidian Canvas.
 */
export interface CanvasEdge {
    id: string;       // Unique identifier for the edge
    fromNode: string; // ID of the source node
    fromSide: string; // Side of the source node (left, right, top, bottom)
    toNode: string;   // ID of the target node
    toSide: string;   // Side of the target node (left, right, top, bottom)
    label?: string;   // Optional text label for the edge
    color?: string;   // Optional color for the edge
}

/**
 * Represents the entire Canvas data structure.
 */
export interface Canvas {
    nodes: CanvasNode[]; // All nodes in the canvas
    edges: CanvasEdge[]; // All edges in the canvas
}

/**
 * Alias for Canvas interface, used for getData/setData methods.
 */
export interface CanvasData {
    nodes: CanvasNode[];
    edges: CanvasEdge[];
}

/**
 * Interface for accessing the Canvas view in Obsidian.
 * Provides methods for getting/setting data and accessing the selection.
 */
export interface CanvasView {
    canvas: {
        getData(): CanvasData;           // Get the current canvas data
        setData(data: CanvasData): void; // Update the canvas data
        requestSave(): void;             // Request Obsidian to save the canvas
        selection: Set<CanvasNode>;      // Currently selected nodes
        menu: {
            menuEl: HTMLElement;         // Canvas context menu element
        };
    };
}

/**
 * Gets the active Canvas view from the Obsidian workspace.
 * 
 * @param app The Obsidian App instance
 * @return The active CanvasView or null if not in a canvas
 */
export function getActiveCanvas(app: App): CanvasView | null {
    try {
        // Instead of using getActiveViewOfType, check if the active leaf has a canvas property
        const activeLeaf = app.workspace.activeLeaf;
        if (!activeLeaf) return null;
        
        const view = activeLeaf.view;
        if (!view) return null;
        
        // Check if this view has a canvas property
        if ((view as any).canvas) {
            return view as unknown as CanvasView;
        }
        
        return null;
    } catch (error) {
        console.error("Error getting active canvas view:", error);
        return null;
    }
}

/**
 * Gets the currently selected node in a Canvas.
 * Returns null if no node is selected or multiple nodes are selected.
 * 
 * @param canvas The Canvas instance
 * @return The selected CanvasNode or null
 */
export function getSelectedNode(canvas: CanvasView["canvas"]): CanvasNode | null {
    try {
        console.log("Canvas selection:", canvas.selection);
        
        if (!canvas.selection || canvas.selection.size !== 1) {
            console.log("No selection or multiple selections");
            return null;
        }
        
        const selectedNode = Array.from(canvas.selection)[0];
        console.log("Selected node:", selectedNode);
        return selectedNode;
    } catch (error) {
        console.error("Error in getSelectedNode:", error);
        return null;
    }
}

/**
 * Gets all currently selected nodes in a Canvas.
 * Returns an empty array if no nodes are selected.
 * 
 * @param canvas The Canvas instance
 * @return Array of selected CanvasNodes
 */
export function getSelectedNodes(canvas: CanvasView["canvas"]): CanvasNode[] {
    try {
        console.log("Canvas selection in getSelectedNodes:", canvas.selection);
        console.log("Canvas selection type:", typeof canvas.selection);
        console.log("Canvas selection is Set:", canvas.selection instanceof Set);
        
        if (!canvas.selection) {
            console.log("Selection is null or undefined");
            return [];
        }
        
        if (canvas.selection.size === 0) {
            console.log("Selection size is 0");
            return [];
        }
        
        // Try to convert the selection to an array
        let selectedNodes: CanvasNode[] = [];
        try {
            selectedNodes = Array.from(canvas.selection);
            console.log("Successfully converted selection to array with length:", selectedNodes.length);
        } catch (conversionError) {
            console.error("Error converting selection to array:", conversionError);
            
            // Fallback: try to manually iterate through the selection
            console.log("Trying manual iteration...");
            selectedNodes = [];
            try {
                canvas.selection.forEach((node: CanvasNode) => {
                    console.log("Found node in selection:", node);
                    selectedNodes.push(node);
                });
                console.log("Manual iteration found nodes:", selectedNodes.length);
            } catch (iterationError) {
                console.error("Error during manual iteration:", iterationError);
            }
        }
        
        console.log("Final selected nodes:", selectedNodes);
        return selectedNodes;
    } catch (error) {
        console.error("Error in getSelectedNodes:", error);
        return [];
    }
}

/**
 * Gets the content of a Canvas node.
 * Handles different node types (text, file) and attempts to extract content.
 * 
 * @param app The Obsidian App instance
 * @param node The CanvasNode to get content from
 * @return The node's content as a string
 */
export async function getNodeContent(app: App, node: CanvasNode): Promise<string> {
    try {
        console.log("Getting content for node:", node);
        
        if (!node) {
            console.log("Node is null or undefined");
            return "";
        }
        
        // Log all properties of the node to help debug
        console.log("Node properties:", Object.keys(node));
        
        // Check if the node has a text property directly
        if (node.text) {
            console.log("Node has text property:", node.text);
            return node.text;
        }
        
        // Check if the node has a content property
        if ((node as any).content) {
            console.log("Node has content property:", (node as any).content);
            return (node as any).content;
        }
        
        // Check if the node has a textContent property
        if ((node as any).textContent) {
            console.log("Node has textContent property:", (node as any).textContent);
            return (node as any).textContent;
        }
        
        // Check if the node has a data property that might contain text
        if ((node as any).data) {
            const data = (node as any).data;
            console.log("Node has data property:", data);
            
            if (typeof data === 'string') {
                return data;
            }
            
            if (data.text) {
                return data.text;
            }
            
            if (data.content) {
                return data.content;
            }
        }
        
        // Try to handle based on type if it exists
        if (node.type) {
            if (node.type === "text") {
                console.log("Node is text type, text content:", node.text);
                return node.text || "";
            } else if (node.type === "file") {
                console.log("Node is file type, file path:", node.file);
                const abstractFile = app.vault.getAbstractFileByPath(node.file || "");
                if (!abstractFile) {
                    console.log("File not found");
                    return "";
                }
                
                if (!(abstractFile instanceof TFile)) {
                    console.log("Not a file");
                    return "";
                }
                
                const file = abstractFile as TFile;
                let content = await app.vault.read(file);
                console.log("File content length:", content.length);
                
                // If there's a subpath, try to extract just that section
                if (node.subpath) {
                    console.log("Node has subpath:", node.subpath);
                    const cache = app.metadataCache.getFileCache(file);
                    if (cache) {
                        try {
                            const resolved = app.metadataCache.getFirstLinkpathDest(node.subpath, file.path);
                            if (resolved) {
                                content = await app.vault.read(resolved);
                                console.log("Subpath content length:", content.length);
                            }
                        } catch (e) {
                            console.error("Error resolving subpath", e);
                        }
                    }
                }
                
                return content;
            } else {
                console.log("Unknown node type:", node.type);
            }
        } else {
            console.log("Node has no type property");
            
            // Check for child property which might contain content
            if ((node as any).child) {
                console.log("Node has child property");
                const child = (node as any).child;
                
                // Try to get content from child
                if (typeof child.getText === 'function') {
                    try {
                        const text = child.getText();
                        console.log("Got text from child.getText():", text);
                        return text;
                    } catch (e) {
                        console.error("Error calling child.getText():", e);
                    }
                }
                
                // Check if child has text property
                if (child.text) {
                    console.log("Child has text property:", child.text);
                    return child.text;
                }
                
                // Check if child has content property
                if (child.content) {
                    console.log("Child has content property:", child.content);
                    return child.content;
                }
                
                // Check if child has value property
                if (child.value) {
                    console.log("Child has value property:", child.value);
                    return child.value;
                }
            }
            
            // Check for contentEl which might contain text
            if ((node as any).contentEl) {
                console.log("Node has contentEl property");
                const contentEl = (node as any).contentEl;
                
                // Try to get innerText or textContent from contentEl
                if (contentEl.innerText) {
                    console.log("ContentEl has innerText:", contentEl.innerText);
                    return contentEl.innerText;
                }
                
                if (contentEl.textContent) {
                    console.log("ContentEl has textContent:", contentEl.textContent);
                    return contentEl.textContent;
                }
            }
            
            // If the node has a getText method, try to call it
            if (typeof (node as any).getText === 'function') {
                try {
                    const text = (node as any).getText();
                    console.log("Got text from getText():", text);
                    return text;
                } catch (e) {
                    console.error("Error calling getText():", e);
                }
            }
            
            // Try to access the DOM element directly
            if ((node as any).nodeEl) {
                const nodeEl = (node as any).nodeEl;
                if (nodeEl.innerText) {
                    console.log("NodeEl has innerText:", nodeEl.innerText);
                    return nodeEl.innerText;
                }
                
                if (nodeEl.textContent) {
                    console.log("NodeEl has textContent:", nodeEl.textContent);
                    return nodeEl.textContent;
                }
            }
        }
        
        return "";
    } catch (error) {
        console.error("Error in getNodeContent:", error);
        return "";
    }
}

/**
 * Creates a new AI response node connected to a parent node.
 * The new node is positioned to the right of the parent node.
 * 
 * @param canvas The Canvas instance
 * @param parentNode The parent node to connect to
 * @param text The text content for the new node
 * @return The created CanvasNode
 */
export function createResponseNode(
    canvas: CanvasView["canvas"], 
    parentNode: CanvasNode, 
    text: string
): CanvasNode {
    const data = canvas.getData();
    
    // Create a new node with AI metadata
    const newNodeId = generateId();
    const newNode: CanvasNode = {
        id: newNodeId,
        x: parentNode.x + parentNode.width + 50,
        y: parentNode.y,
        width: parentNode.width,
        height: calculateHeight(text, parentNode.width),
        type: "text",
        text: text,
        metadata: {
            isAIGenerated: true,
            generationType: 'response',
            timestamp: Date.now()
        }
    };
    
    // Create an edge connecting the parent to the new node
    const newEdgeId = generateId();
    const newEdge: CanvasEdge = {
        id: newEdgeId,
        fromNode: parentNode.id,
        fromSide: "right",
        toNode: newNodeId,
        toSide: "left",
        color: "6", // Purple
    };
    
    // Update the canvas
    data.nodes.push(newNode);
    data.edges.push(newEdge);
    canvas.setData(data);
    canvas.requestSave();
    
    return newNode;
}

/**
 * Creates a new prompt node connected to multiple source nodes.
 * The new node is positioned based on the average position of the source nodes.
 * 
 * @param canvas The Canvas instance
 * @param sourceNodes Array of source nodes to connect to
 * @return The created CanvasNode or null if sourceNodes is empty
 */
export function createPromptNode(
    canvas: CanvasView["canvas"],
    sourceNodes: CanvasNode[]
): CanvasNode | null {
    if (sourceNodes.length === 0) return null;
    
    const data = canvas.getData();
    
    // Calculate the average position of all selected nodes
    let avgX = 0;
    let avgY = 0;
    let maxWidth = 0;
    
    sourceNodes.forEach(node => {
        avgX += node.x + node.width / 2;
        avgY += node.y + node.height / 2;
        maxWidth = Math.max(maxWidth, node.width);
    });
    
    avgX = avgX / sourceNodes.length;
    avgY = avgY / sourceNodes.length;
    
    // Create a new prompt node with AI metadata
    const newNodeId = generateId();
    const newNode: CanvasNode = {
        id: newNodeId,
        x: avgX + 100, // Position to the right of the average
        y: avgY - 50,  // Position slightly above the average
        width: maxWidth,
        height: 100,
        type: "text",
        text: "Enter your prompt here...",
        metadata: {
            isAIGenerated: true,
            generationType: 'prompt',
            timestamp: Date.now()
        }
    };
    
    // Create edges connecting each source node to the new node
    const newEdges: CanvasEdge[] = sourceNodes.map(sourceNode => {
        return {
            id: generateId(),
            fromNode: sourceNode.id,
            fromSide: "right",
            toNode: newNodeId,
            toSide: "left",
            color: "5", // Blue
        };
    });
    
    // Update the canvas
    data.nodes.push(newNode);
    data.edges.push(...newEdges);
    canvas.setData(data);
    canvas.requestSave();
    
    return newNode;
}

/**
 * Updates the content of an existing Canvas node.
 * Also adjusts the node height based on the new content.
 * 
 * @param canvas The Canvas instance
 * @param node The node to update
 * @param text The new text content
 */
export function updateNodeContent(
    canvas: CanvasView["canvas"],
    node: CanvasNode,
    text: string
): void {
    const data = canvas.getData();
    
    // Find the node in the data
    const nodeIndex = data.nodes.findIndex(n => n.id === node.id);
    if (nodeIndex === -1) return;
    
    // Update the node text and height
    data.nodes[nodeIndex].text = text;
    data.nodes[nodeIndex].height = calculateHeight(text, node.width);
    
    // Update the canvas
    canvas.setData(data);
    canvas.requestSave();
}

/**
 * Gets all nodes connected to a specific node.
 * Only returns nodes that have edges pointing to the specified node.
 * 
 * @param canvas The Canvas instance
 * @param node The node to find connections to
 * @return Array of connected nodes
 */
export function getConnectedNodes(
    canvas: CanvasView["canvas"],
    node: CanvasNode
): CanvasNode[] {
    try {
        const data = canvas.getData();
        const connectedNodes: CanvasNode[] = [];
        
        // Find all edges where this node is the destination
        const incomingEdges = data.edges.filter(edge => edge.toNode === node.id);
        
        // Get the source nodes for these edges
        incomingEdges.forEach(edge => {
            const sourceNode = data.nodes.find(n => n.id === edge.fromNode);
            if (sourceNode) {
                connectedNodes.push(sourceNode);
            }
        });
        
        return connectedNodes;
    } catch (error) {
        console.error("Error in getConnectedNodes:", error);
        return [];
    }
}

/**
 * Creates a question and answer pair of nodes connected to a parent node.
 * The question node is connected to the parent, and the answer node is connected to the question.
 * 
 * @param canvas The Canvas instance
 * @param parentNode The parent node to connect to
 * @param question The question text
 * @param answer The answer text
 */
export function createQuestionNode(
    canvas: CanvasView["canvas"], 
    parentNode: CanvasNode, 
    question: string,
    answer: string
): void {
    const data = canvas.getData();
    
    // Create a new node for the question with AI metadata
    const questionNodeId = generateId();
    const questionNode: CanvasNode = {
        id: questionNodeId,
        x: parentNode.x + parentNode.width + 50,
        y: parentNode.y,
        width: parentNode.width,
        height: calculateHeight(question, parentNode.width),
        type: "text",
        text: `Question: ${question}`,
        metadata: {
            isAIGenerated: true,
            generationType: 'prompt',
            timestamp: Date.now()
        }
    };
    
    // Create a new node for the answer with AI metadata
    const answerNodeId = generateId();
    const answerNode: CanvasNode = {
        id: answerNodeId,
        x: questionNode.x + questionNode.width + 50,
        y: questionNode.y,
        width: parentNode.width,
        height: calculateHeight(answer, parentNode.width),
        type: "text",
        text: answer,
        metadata: {
            isAIGenerated: true,
            generationType: 'response',
            timestamp: Date.now()
        }
    };
    
    // Create an edge connecting the parent to the question node
    const parentToQuestionEdgeId = generateId();
    const parentToQuestionEdge: CanvasEdge = {
        id: parentToQuestionEdgeId,
        fromNode: parentNode.id,
        fromSide: "right",
        toNode: questionNodeId,
        toSide: "left",
        color: "5", // Blue
    };
    
    // Create an edge connecting the question to the answer node
    const questionToAnswerEdgeId = generateId();
    const questionToAnswerEdge: CanvasEdge = {
        id: questionToAnswerEdgeId,
        fromNode: questionNodeId,
        fromSide: "right",
        toNode: answerNodeId,
        toSide: "left",
        color: "6", // Purple
    };
    
    // Update the canvas
    data.nodes.push(questionNode, answerNode);
    data.edges.push(parentToQuestionEdge, questionToAnswerEdge);
    canvas.setData(data);
    canvas.requestSave();
}

/**
 * Generates a random ID for new Canvas nodes and edges.
 * 
 * @return A random string ID
 */
function generateId(): string {
    return Math.random().toString(36).substring(2, 15);
}

/**
 * Calculates an appropriate height for a node based on its text content and width.
 * Uses a rough estimate of characters per line and line height.
 * 
 * @param text The text content
 * @param width The node width
 * @return The calculated height in pixels
 */
function calculateHeight(text: string, width: number): number {
    // Ensure text is defined before accessing its length
    if (!text) {
        return 100; // Default height if text is undefined
    }
    
    // Rough estimate: 20px per line, assuming ~5 chars per pixel
    const charsPerLine = width / 5;
    const lines = Math.ceil(text.length / charsPerLine);
    return Math.max(100, lines * 20);
}
